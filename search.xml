<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>8/10-8/16 schedule</title>
    <url>/2020/08/10/8-10-8-16-schedule/</url>
    <content><![CDATA[<h1 id="8-10-8-16-schedule"><a href="#8-10-8-16-schedule" class="headerlink" title="8/10-8/16 schedule"></a>8/10-8/16 schedule</h1><table>
<thead>
<tr>
<th>Time</th>
<th align="center">Mon</th>
<th>Tue</th>
<th>Wed</th>
<th>Thu</th>
<th>Fri</th>
<th>Sat</th>
<th>Sun</th>
</tr>
</thead>
<tbody><tr>
<td>8:00 am - 10:00 am</td>
<td align="center">FIT5147 Lab 预习</td>
<td>FIT5140 Lecture</td>
<td>练习听力 + 预习FIT5042</td>
<td>练习 听力 + SWIFT</td>
<td>练习听力 + Leetcode  Java</td>
<td>记单词+ Leetcode  Java</td>
<td>记单词+ Leetcode  Java</td>
</tr>
<tr>
<td>10:00 am - 12: 00 am</td>
<td align="center">leetcode Java</td>
<td>练习 SWIFT</td>
<td>预习FIT5042</td>
<td>Leetcode Java</td>
<td>FIT5147 Lec</td>
<td>接Min</td>
<td>Leetcode  Java</td>
</tr>
<tr>
<td>12:00pm - 1:50pm</td>
<td align="center">吃饭 &amp;&amp; 午睡</td>
<td>吃饭 &amp;&amp; 午睡</td>
<td>FIT5042 Lab</td>
<td>吃饭 &amp;&amp; 午睡</td>
<td>吃饭 &amp;&amp; 午睡</td>
<td>休息</td>
<td>吃饭 &amp;&amp; 午睡</td>
</tr>
<tr>
<td>2:00 pm - 4: 00 pm</td>
<td align="center">练习FIT5147 lab内容</td>
<td>预习FIT5202</td>
<td>FIT5042 Lab + 锻炼</td>
<td>预习FIT5042(Spring MVC)</td>
<td>预习FIT5140</td>
<td>Leetcode  Java</td>
<td>练习 d3</td>
</tr>
<tr>
<td>4:00 pm - 6: 00 pm</td>
<td align="center">选课</td>
<td>预习FIT5202 +  Ios 练习</td>
<td>休息+ 练习 leetcode</td>
<td>Leetcode Java + 吃饭</td>
<td>Leetcode  Java + 吃饭</td>
<td>练习 Swift</td>
<td>送Min</td>
</tr>
<tr>
<td>6: 00 pm - 7: 00pm</td>
<td align="center">Swift 练习</td>
<td>IOS 练习</td>
<td>吃饭 &amp;&amp; 休息</td>
<td>FIT5137  Lecture</td>
<td>FIT5140 Lab</td>
<td>吃饭 &amp;&amp; 休息</td>
<td>吃饭 &amp;&amp; 休息</td>
</tr>
<tr>
<td>7: 00 pm - 8: 00 pm</td>
<td align="center">FIT5147 Lab</td>
<td>FIT5042 Lecture</td>
<td>FIT5202 Lec</td>
<td>FIT5137  Lecture</td>
<td>FIT5140 Lab</td>
<td>休息</td>
<td>锻炼</td>
</tr>
<tr>
<td>8: 00 pm - 10: 00 pm</td>
<td align="center">FIT5147 Lab+吃饭</td>
<td>FIT5042 Lecture+ 吃饭</td>
<td>Leetcode Java + 锻炼</td>
<td>Leetcode Java + 锻炼</td>
<td>刷 面试题</td>
<td>练习 R</td>
<td>刷面试题 + 定 下周计划</td>
</tr>
<tr>
<td>10:00 pm - 11: 30 pm</td>
<td align="center">博客总结  + 洗漱   然后睡觉</td>
<td>博客总结  + 洗漱   然后睡觉</td>
<td>博客总结  + 洗漱   然后睡觉</td>
<td>博客总结  + 洗漱   然后睡觉</td>
<td>博客总结  + 洗漱   然后睡觉</td>
<td>博客总结  + 洗漱   然后睡觉</td>
<td>博客总结  + 洗漱   然后睡觉</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>schedule</category>
      </categories>
      <tags>
        <tag>schedule</tag>
      </tags>
  </entry>
  <entry>
    <title>8/03-8/09 schedule</title>
    <url>/2020/08/02/8-03-8-09-schedual/</url>
    <content><![CDATA[<h1 id="8-03-8-09-schedule"><a href="#8-03-8-09-schedule" class="headerlink" title="8/03-8/09 schedule"></a>8/03-8/09 schedule</h1><table>
<thead>
<tr>
<th>Time</th>
<th>Mon</th>
<th>Tue</th>
<th>Wed</th>
<th>Thu</th>
<th>Fri</th>
<th>Sat</th>
<th>Sun</th>
</tr>
</thead>
<tbody><tr>
<td>8:00 am - 10:00 am</td>
<td>FIT5147 Lab</td>
<td>FIT5140 Lecture</td>
<td>练习听力 + Leetcode  Java</td>
<td>练习 听力 + SWIFT</td>
<td>练习听力 + Leetcode  Java</td>
<td>记单词+ Leetcode  Java</td>
<td>记单词+ Leetcode  Java</td>
</tr>
<tr>
<td>10:00 am - 12: 00 am</td>
<td>Leetcode   Java</td>
<td>练习 SWIFT</td>
<td>预习FIT5042</td>
<td>Leetcode Java</td>
<td>FIT5147 Lec</td>
<td>休息</td>
<td>Leetcode  Java</td>
</tr>
<tr>
<td>12:00pm - 1:50pm</td>
<td>吃饭 &amp;&amp; 午睡</td>
<td>吃饭 &amp;&amp; 午睡</td>
<td>FIT5042 Lab</td>
<td>吃饭 &amp;&amp; 午睡</td>
<td>吃饭 &amp;&amp; 午睡</td>
<td>休息</td>
<td>吃饭 &amp;&amp; 午睡</td>
</tr>
<tr>
<td>2:00 pm - 4: 00 pm</td>
<td>FIT5137 Lab</td>
<td>预习FIT5042(Spring MVC)</td>
<td>FIT5042 Lab + 锻炼</td>
<td>预习FIT5042(Spring MVC)</td>
<td>预习FIT5140</td>
<td>Leetcode  Java</td>
<td>练习 d3</td>
</tr>
<tr>
<td>4:00 pm - 6: 00 pm</td>
<td>学习 Java EE</td>
<td>Leetcode Java +  FIT5202 Lab</td>
<td>休息+ 练习 R</td>
<td>Leetcode Java + 吃饭</td>
<td>Leetcode  Java + 吃饭</td>
<td>练习 Swift</td>
<td>送 Min</td>
</tr>
<tr>
<td>6: 00 pm - 7: 00pm</td>
<td>吃饭 &amp;&amp; 休息</td>
<td>FIT5202 Lab</td>
<td>吃饭 &amp;&amp; 休息</td>
<td>FIT5137  Lecture</td>
<td>FIT5140 Lab</td>
<td>吃饭 &amp;&amp; 休息</td>
<td>吃饭 &amp;&amp; 休息</td>
</tr>
<tr>
<td>7: 00 pm - 8: 00 pm</td>
<td>锻炼</td>
<td>FIT5042 Lecture</td>
<td>FIT5202 Lec</td>
<td>FIT5137  Lecture</td>
<td>FIT5140 Lab</td>
<td>休息</td>
<td>锻炼</td>
</tr>
<tr>
<td>8: 00 pm - 10: 00 pm</td>
<td>Leetcode  Java</td>
<td>FIT5042 Lecture+ 吃饭</td>
<td>Leetcode Java + 锻炼</td>
<td>Leetcode Java + 锻炼</td>
<td>刷 面试题</td>
<td>练习 R</td>
<td>刷面试题 + 定 下周计划</td>
</tr>
<tr>
<td>10:00 pm - 11: 30 pm</td>
<td>博客总结  + 洗漱   然后睡觉</td>
<td>博客总结  + 洗漱   然后睡觉</td>
<td>博客总结  + 洗漱   然后睡觉</td>
<td>博客总结  + 洗漱   然后睡觉</td>
<td>博客总结  + 洗漱   然后睡觉</td>
<td>博客总结  + 洗漱   然后睡觉</td>
<td>博客总结  + 洗漱   然后睡觉</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>schedule</category>
      </categories>
      <tags>
        <tag>schedule</tag>
      </tags>
  </entry>
  <entry>
    <title>FIT5042 JSF</title>
    <url>/2020/08/12/FIT5042-1/</url>
    <content><![CDATA[<p> Lecturer 讲得太尴尬了。每次两小时的tutorial，讲10分钟要做什么然后就自己开始照着资料做。很多概念也没讲，这门课真的小白从到一点点学。</p>
<h1 id="JSF"><a href="#JSF" class="headerlink" title="JSF"></a>JSF</h1><p><strong><em>JSF</em></strong>(JavaServer Faces)是基于服务端组件的用户界面框架。JSF 的优势之一是不仅是Java Web用户界面标准还是遵循MVC设计模式的框架。清晰的WEB应用程序的行为和呈现之间的分离。 用户界面代码(V), 应用程序数据和逻辑(M). 为了防止对页面未授权或不正当的访问，所有与应用程序的用户交互均由一个前端”Faces” servlet (C) 来处理。 V–&gt;视图   M—&gt;模型 C—&gt; 控制器。</p>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p><a href="https://www.runoob.com/servlet/servlet-intro.html" target="_blank" rel="noopener">Servlet是什么</a></p>
<p>Java Servlet 是作为Http 客户端的请求和数据库的之间的中间层。 </p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/13/nZOsQJHvxkKmpaC.png" alt=""></p>
<h2 id="Java-Bean"><a href="#Java-Bean" class="headerlink" title="Java Bean"></a>Java Bean</h2><p> Java Bean 就是一个java 普通的类，通常用来实现一些比较常用的简单功能，并可以很容易被重复使用或者插入其他应用中去。Java Bean 是一种组件技术，就像是做了一个扳手，而这个扳手可以在很多地方使用，也可以提供很多功能(扳，锤，撬)， 而这个扳手就是一个组件.</p>
<p>Bean的含义是可重复使用的Java组件。所谓组件就是一个由可以自行进行内部管理的一个或几个类组成.  并且外界不了解其内部信息和运行方式的群体.   使用它的对象只能通过接口来操作.</p>
<p>但是Java Bean有额外的要求： </p>
<ol>
<li><p>这个类需是public.   并且有一个default constructor. </p>
</li>
<li><p>这个类的属性必须是private,通过public 类型的setXxx() 和 getXxx() 访问. </p>
</li>
<li><p>可以把bean的状态保存在硬盘上，以便后来可以恢复。</p>
</li>
<li><p>这个类要能支持”事件”,比如addXxxListener(XxxEvent e),事件可以是click事件,keyboard事件，自定义事件等</p>
</li>
<li><p>所有的JavaBean必须放在一个包（package）中。</p>
<p><a href="https://juejin.im/post/6844903906623881230" target="_blank" rel="noopener">Java Bean 掘金</a></p>
</li>
</ol>
<p>​      <a href="https://stackoverflow.com/questions/1612334/difference-between-dto-vo-pojo-javabeans" target="_blank" rel="noopener">Java Bean vs POJO vs VO</a></p>
<p>​        </p>
]]></content>
      <tags>
        <tag>Enterprise application development for the web</tag>
      </tags>
  </entry>
  <entry>
    <title>8-31-9-6-schedule</title>
    <url>/2020/08/30/8-31-9-6-schedule/</url>
    <content><![CDATA[<p>title: 8-31-9-6-schedule<br>date: 2020-08-30 20:14:00<br>tags: schedule<br>categories: schedule</p>
<h1 id="8-30–9-06-schedule"><a href="#8-30–9-06-schedule" class="headerlink" title="8/30–9/06 schedule"></a>8/30–9/06 schedule</h1><table>
<thead>
<tr>
<th>Time</th>
<th align="center">Mon</th>
<th>Tue</th>
<th>Wed</th>
<th>Thu</th>
<th>Fri</th>
<th>Sat</th>
<th>Sun</th>
</tr>
</thead>
<tbody><tr>
<td>8:00 am - 10:00 am</td>
<td align="center">FIT5147 ASSESS</td>
<td>FIT5140 Lecture</td>
<td>FIT5140 ASSESS</td>
<td>练习 听力 + FIT5140</td>
<td>练习听力 + Leetcode  Java</td>
<td>记单词+ Leetcode  Java</td>
<td>记单词+ Leetcode  Java</td>
</tr>
<tr>
<td>10:00 am - 12: 00 am</td>
<td align="center">leetcode Java + interview</td>
<td>FIT5140 lab 作业</td>
<td>FIT5163 LEC</td>
<td>Leetcode Java</td>
<td>FIT5147 Lec</td>
<td>接Min</td>
<td>Leetcode  Java</td>
</tr>
<tr>
<td>12:00pm - 1:50pm</td>
<td align="center">吃饭 &amp;&amp; 午睡</td>
<td>吃饭 &amp;&amp; 午睡</td>
<td>FIT5163 LEC</td>
<td>吃饭 &amp;&amp; 午睡</td>
<td>FIT5042 lab</td>
<td>休息</td>
<td>吃饭 &amp;&amp; 午睡</td>
</tr>
<tr>
<td>2:00 pm - 4: 00 pm</td>
<td align="center">FIT5163 lab</td>
<td>FIT5042 lab 作业</td>
<td>FIT5042  LAB</td>
<td>预习FIT5042</td>
<td>FIT5140 ASSESS</td>
<td>Leetcode  Java</td>
<td>FIT5140 ASSESS</td>
</tr>
<tr>
<td>4:00 pm - 6: 00 pm</td>
<td align="center">FIT5042 ASSESS</td>
<td>FIT5147 ASSESS</td>
<td>休息+ leetcode</td>
<td>Leetcode Java + 吃饭</td>
<td>Leetcode  Java + 吃饭</td>
<td>FIT5140 ASSESS</td>
<td>送Min</td>
</tr>
<tr>
<td>6: 00 pm - 7: 00pm</td>
<td align="center">FIT5042 ASSESS</td>
<td>FIT5147 ASSESS</td>
<td>吃饭 &amp;&amp; 休息</td>
<td>FIT5147  Lecture</td>
<td>FIT5140 Lab</td>
<td>吃饭 &amp;&amp; 休息</td>
<td>吃饭 &amp;&amp; 休息</td>
</tr>
<tr>
<td>7: 00 pm - 8: 00 pm</td>
<td align="center">FIT5147 Lab</td>
<td>FIT5042 Lecture+吃饭</td>
<td>FIT5163</td>
<td>FIT5147 Lecture</td>
<td>FIT5140 Lab</td>
<td>休息</td>
<td>锻炼</td>
</tr>
<tr>
<td>8: 00 pm - 10: 00 pm</td>
<td align="center">FIT5147 Lab+吃饭</td>
<td>FIT5042 Lecture</td>
<td>Leetcode Java + 锻炼</td>
<td>Leetcode Java + 锻炼</td>
<td>FIT5140  ASSESS</td>
<td>FIT5147 ASSESS</td>
<td>刷面试题 + 定 下周计划</td>
</tr>
<tr>
<td>10:00 pm - 11: 30 pm</td>
<td align="center">FIT5042 LAB 作业</td>
<td>FIT5140 lab 作业</td>
<td>博客总结  + 洗漱   然后睡觉</td>
<td>博客总结  + 洗漱   然后睡觉</td>
<td>FIT5140  ASSESS</td>
<td>博客总结  + 洗漱   然后睡觉</td>
<td>博客总结  + 洗漱   然后睡觉</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>Backtricking Algorithm</title>
    <url>/2021/07/16/Backtricking-Algorithm/</url>
    <content><![CDATA[<h2 id="回溯算法-Backtricking"><a href="#回溯算法-Backtricking" class="headerlink" title="回溯算法(Backtricking)"></a>回溯算法(Backtricking)</h2><p> 回溯逻辑部分一般存在递归函数下面</p>
<h2 id="解决那些问题"><a href="#解决那些问题" class="headerlink" title="解决那些问题"></a>解决那些问题</h2><ul>
<li><p>组合问题 </p>
<p>​     Eg: 给定 {1，2，3，4} 集合， 找到大小为2的组合。 </p>
</li>
<li><p>切割问题 </p>
<p>​     Eg：给定一串字符串，特定条件下，问有几种切割的方式。</p>
</li>
<li><p>子集问题</p>
<p>​     Eg: 给定 {1，2，3，4} 集合，找到它的所有子集。</p>
</li>
<li><p>排列问题</p>
<p>​      Eg: 讲顺序的组合问题</p>
</li>
<li><p>棋盘问题</p>
<p>​    Eg: N-Queen 和 解数独</p>
</li>
</ul>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul>
<li><p>把回溯法问题最好抽象成图形结构，比如树结构。更好的方便理解。</p>
<p> 树的宽度，就是处理问题集合的大小。<font color=red> <strong>这里通常用for循环遍历</strong> </font></p>
<p> 树的深度，就是递归函数的深度。  <font color=red>    <strong>这里就是递归函数处理</strong></font></p>
<p> <img src= "/img/loading.gif" data-src="/img/backtrickTemplete.png" alt="图形结构"></p>
</li>
<li><p>回溯就是递归的过程</p>
<ol>
<li><p>递归就一定有终止条件。</p>
</li>
<li><p>在这里递归函数没有返回值 </p>
</li>
</ol>
</li>
<li><p>模板</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">backtricking</span><span class="params">(parameters)</span></span>&#123;</span><br><span class="line">  <span class="comment">//递归终止 和 收集结果</span></span><br><span class="line">  <span class="keyword">if</span>(终止条件)&#123;</span><br><span class="line">   <span class="comment">// 收集结果</span></span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//单层搜索逻辑</span></span><br><span class="line">  <span class="comment">//for循环 处理集合里每一个搜索元素，树中节点孩子的数量就是集合大小</span></span><br><span class="line">  <span class="keyword">for</span>(本层集合元素集)&#123;</span><br><span class="line">    <span class="comment">// 根据条件 处理节点 以便于在满足终止条件时收集结果。</span></span><br><span class="line">    <span class="comment">// 递归过程 backtricking(parameters)</span></span><br><span class="line">    <span class="comment">// 回溯操作，撤销上一步处理节点的情况。比如: &#123;1,2&#125; 要把2 弹出去重新变成&#123;1&#125; 才能允许3再加进去。 </span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>







</li>
</ul>
]]></content>
      <categories>
        <category>Backtricking Algorithm</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Backtricking Algorithm</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode Array 1</title>
    <url>/2020/08/03/LeetcodeTwoSum1/</url>
    <content><![CDATA[<h1 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h1><h2 id="Question-Easy"><a href="#Question-Easy" class="headerlink" title="Question     * Easy *"></a>Question     <strong>* Easy *</strong></h2><h3 id="Given-an-array-of-integers-return-indices-of-the-two-numbers-such-that-they-add-up-to-a-specific-target-You-may-assume-that-each-input-would-have-exactly-one-solution-and-you-may-not-use-the-same-element-twice"><a href="#Given-an-array-of-integers-return-indices-of-the-two-numbers-such-that-they-add-up-to-a-specific-target-You-may-assume-that-each-input-would-have-exactly-one-solution-and-you-may-not-use-the-same-element-twice" class="headerlink" title="Given an array of integers, return indices of the two numbers such that they add up to a specific target.  (You may assume that each input would have exactly one solution, and you may not use the same element twice.)"></a>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.  (You may assume that each input would have <strong><em>exactly</em></strong> one solution, and you may not use the <em>same</em> element twice.)</h3><h2 id="Hints："><a href="#Hints：" class="headerlink" title="Hints："></a>Hints：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure>

<h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] resultArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">                 result = nums[i] + nums[j]; </span><br><span class="line">                 <span class="keyword">if</span>(result == target)&#123;</span><br><span class="line">                      resultArray[<span class="number">0</span>] = i;</span><br><span class="line">                      resultArray[<span class="number">1</span>] = j;</span><br><span class="line">                      <span class="keyword">return</span> resultArray; </span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">     &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">         System.out.println(<span class="string">"There is no solution"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> resultArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我的想法是 通过遍历所提供的数组，如果可以找到两数相加等于目标数。这样就可以返回这两个数字的Index。然后把这两个数的Index 形成一个新的数组作为return。  </p>
<p>  但是我在看solution的时候，发现我的解题思路被归类为 Brute Force.  solution里面还有其他方法 Two- pass Hash Table, One-Pass Hash Table.  我的解题方法被归类为Brute Force是因为 time complexity == O($n^2$) .  我的这种方法对于每一个元素，每一次loop数组剩下的元素查找它的补数需要花的时间是O(n)，所以两层for循环下来 time complexity == O($n^2$). 可见下图，我的方法不是优解，时间复杂度有点高。</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/03/nvqw9jb2zcUtxXZ.png" alt=""></p>
<h2 id="TIME-COMPLEXITY"><a href="#TIME-COMPLEXITY" class="headerlink" title="TIME COMPLEXITY"></a>TIME COMPLEXITY</h2><p>​    语句执行次数称为语句频度或时间频度,记为T(n)。 有了基本操作执行次数的函数T(n)也无法准确比较代码的运行时间。 比如算法A T(n) = 100n, 算法B T(n) = 5$n^2$,算法A和算法B谁的运行时间长就和n的取值有关了。因此有了<strong><em>渐进时间复杂度</em></strong> (Asymptotic  Time Complexity)的概念.   </p>
<p>​    若有某个<strong>辅助函数f(n)</strong>,使得当n趋近于无穷大时，T(n) /  f(n)  的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作：T(n)  =  O(f(n))， 称 O(f(n)) 为算法的渐进时间复杂度，简称<strong><em>时间复杂度</em></strong>，也称大O表示法。   <strong><em>时间复杂度决定了程序的运行效率，因此特别重要</em></strong></p>
<p>   <strong>时间复杂度原则</strong>： </p>
<ol>
<li><strong><em>如果运行时间 T(n)是常数量级，则 O(1) 表示。</em></strong></li>
<li><strong><em>T(n) 只保留时间函数中的最高阶项。</em></strong></li>
<li><strong><em>T(n) 可以省去最够阶项前面的系数。</em></strong> </li>
</ol>
<p>这篇简书的文章写的很好：<a href="https://www.jianshu.com/p/f4cca5ce055a" target="_blank" rel="noopener">https://www.jianshu.com/p/f4cca5ce055a</a></p>
<p>这篇漫画解释时间复杂度及其重要性也写得很好：<a href="https://www.cxyxiaowu.com/5323.html" target="_blank" rel="noopener">https://www.cxyxiaowu.com/5323.html</a></p>
<h2 id="Two-pass-Hash-Table"><a href="#Two-pass-Hash-Table" class="headerlink" title="Two-pass Hash Table"></a>Two-pass Hash Table</h2><p>  利用hash table，将空间换为速度从而把查找时间降低。利用hash table几乎可以快速查找。“几乎”是因为冲突发生，查找时间还是会退化回去。  在Two-pass Hash Table里面会用到两次iterations.第一次是把每一个元素的value和index添加进table。第二次是查找元素的补数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, map.get(complement) &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，时间复杂度就是O(n)，显然没有嵌套的for循环。 每一次查询时间是O(1). </p>
<h2 id="One-pass-Hash-Table"><a href="#One-pass-Hash-Table" class="headerlink" title="One-pass Hash Table"></a>One-pass Hash Table</h2><p> 和 two-pass hash table 不同的就是， one-pass hash table可以 <strong><em>insert</em></strong> element into table 的时候 <strong><em>check</em></strong> 当前 元素的补数是否已经存在表格里了。如果存在 则返回solution。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; map.get(complement), i &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 时间复杂度也显然是O(n). 空间复杂度也是O(n)，额外的空间取决于有多少的items要存进hash table. </p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>   <strong>创建对象</strong>——&gt;  <code>HashMap&lt;String,Integer&gt; hashMap = new HashMap&lt;&gt;();</code></p>
<p>   <strong>存储数据</strong>   通过put （key,value)——&gt; <code>hashMap.put(&quot;aa&quot;,1);</code></p>
<p>   put方法会覆盖原有的value。另一种方法putIfAbsent(key,value) 不会覆盖。 </p>
<p>​    <code>hashMap.putIfAbsent(&quot;aa&quot;,4);</code></p>
<p>   <strong>删除元素</strong>  </p>
<p>   remove(key):删除成功(存在key)，返回被删除的key对应的value，否则返回null。</p>
<p>   remove(key,value):删除成功（存在entry），返回true，否则返回false。 </p>
<p>​    <code>hashMap.remove(&quot;aa&quot;,5);</code></p>
<p>   <strong>获取元素</strong></p>
<p>   <code>hashMap.get(&quot;aa&quot;);</code></p>
<p>   getOrDefault在key不存在时,返回一个defaultValue。</p>
<p>​    <code>getOrDefault(&quot;aa&quot;,-1);</code></p>
<p>  <strong>元素遍历</strong></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Iterator iterator &#x3D; hashMap.keySet().iterator();</span><br><span class="line">while (iterator.hasNext())&#123;</span><br><span class="line">    String key &#x3D; (String)iterator.next();</span><br><span class="line">    System.out.println(key+&quot;&#x3D;&quot;+hashMap.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判断Key或者value是否存在</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hashMap.containsKey(&quot;aa&quot;);</span><br><span class="line">hashMap.containsValue(1);</span><br></pre></td></tr></table></figure>

<p><strong>替换元素</strong></p>
<p><code>hashMap.replace(&quot;ff&quot;,5);</code></p>
]]></content>
      <categories>
        <category>Leetcode Algorithm</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Leetcode Algorithm</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode Array 3</title>
    <url>/2020/08/10/Leetcode-Array-3/</url>
    <content><![CDATA[<h1 id="Remove-Element"><a href="#Remove-Element" class="headerlink" title="Remove Element"></a>Remove Element</h1><h2 id="Question-Easy"><a href="#Question-Easy" class="headerlink" title="Question     * Easy *"></a>Question     <strong>* Easy *</strong></h2><h3 id="Given-an-array-nums-and-a-value-val-remove-all-instances-of-that-value-in-place-and-return-the-new-length-Do-not-allocate-extra-space-for-another-array-you-must-do-this-by-modifying-the-input-array-in-place-with-O-1-extra-memory-The-order-of-elements-can-be-changed-It-doesn’t-matter-what-you-leave-beyond-the-new-length"><a href="#Given-an-array-nums-and-a-value-val-remove-all-instances-of-that-value-in-place-and-return-the-new-length-Do-not-allocate-extra-space-for-another-array-you-must-do-this-by-modifying-the-input-array-in-place-with-O-1-extra-memory-The-order-of-elements-can-be-changed-It-doesn’t-matter-what-you-leave-beyond-the-new-length" class="headerlink" title="Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length."></a>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> and return the new length. Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</h3><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [3,2,2,3], val &#x3D; 3,</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 2, with the first two elements of nums being 2.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2,</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</span><br><span class="line"></span><br><span class="line">Note that the order of those five elements can be arbitrary.</span><br></pre></td></tr></table></figure>

<h2 id="My-solution"><a href="#My-solution" class="headerlink" title="My solution"></a>My solution</h2><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> tt = <span class="keyword">true</span>; </span><br><span class="line">       <span class="keyword">int</span> k; </span><br><span class="line">       <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> temp;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> z=<span class="number">0</span>;z &lt; nums.length;z++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(nums[z] != val)&#123;</span><br><span class="line">              f++;</span><br><span class="line">          &#125;          </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;f;i++)&#123;</span><br><span class="line">          tt = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (nums[i] == val )&#123;</span><br><span class="line">              k = i;</span><br><span class="line">            <span class="keyword">while</span>(tt)&#123;</span><br><span class="line">               k++;</span><br><span class="line">               <span class="keyword">if</span>(nums[k] != val)&#123;</span><br><span class="line">                   tt=<span class="keyword">false</span>;</span><br><span class="line">                   temp = nums[i];  </span><br><span class="line">                   nums[i] = nums[k];</span><br><span class="line">                   nums[k] = temp;</span><br><span class="line">               &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;          </span><br><span class="line"> <span class="keyword">return</span> f;       </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法比较“笨”。 首先计算数组nums里面不等于val的个数 X。 最后就是利用循环，数组里面等于val的item被离这个item最近的不等于val的数字数字替代。 也可以说他们是交换位置。这是这个方法的思路。</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/10/lJFOaSZGkECoyHs.png" alt=""></p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/10/c7pCsdRFGfbT8Ko.png" alt=""></p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != val)&#123;</span><br><span class="line">                nums[index] = nums[i];</span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> index;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法说实话很巧，和Leetcode solution中的一个思路很像。 大致思路就是循环这个数组把不等于val 的item逐个移到数组的前面。返回的index也就是数组中不等于val的个数。</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/10/lJFOaSZGkECoyHs.png" alt=""></p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/10/ApLQOtgT8XkqKBV.png" alt=""></p>
<h2 id="Leetcode-Solution"><a href="#Leetcode-Solution" class="headerlink" title="Leetcode Solution"></a>Leetcode Solution</h2> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">            nums[i] = nums[n - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// reduce array size by one</span></span><br><span class="line">            n--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When we encounter <strong>nums[i]=val</strong>, we can swap the current element out with the last element and dispose the last one. This essentially reduces the array’s size by 1.</p>
<p>Note that the last element that was swapped in could be the value you want to remove itself. But don’t worry, in the next iteration we will still check this element.</p>
<h3 id="Leetcode-Clarification"><a href="#Leetcode-Clarification" class="headerlink" title="Leetcode Clarification"></a>Leetcode Clarification</h3><p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len &#x3D; removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; any modification to nums in your function would be known by the caller.</span><br><span class="line">&#x2F;&#x2F; using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode Algorithm</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Leetcode Algorithm</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode Array 2</title>
    <url>/2020/08/04/LeetcodeTwoSum2/</url>
    <content><![CDATA[<h1 id="Remove-Duplicates-from-Sorted-Array"><a href="#Remove-Duplicates-from-Sorted-Array" class="headerlink" title="Remove Duplicates from Sorted Array"></a>Remove Duplicates from Sorted Array</h1><h2 id="Question-Easy"><a href="#Question-Easy" class="headerlink" title="Question     * Easy *"></a>Question     <strong>* Easy *</strong></h2><h3 id="Given-a-sorted-array-nums-remove-the-duplicates-in-place-such-that-each-element-appear-only-once-and-return-the-new-length"><a href="#Given-a-sorted-array-nums-remove-the-duplicates-in-place-such-that-each-element-appear-only-once-and-return-the-new-length" class="headerlink" title="Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length."></a>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</h3><p>Do not allocate extra space for another array, you must do this by <strong><em>modifying the input array</em></strong> <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a> with O(1) extra memory.</p>
<h2 id="Hints"><a href="#Hints" class="headerlink" title="Hints:"></a>Hints:</h2><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length &#x3D; 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&#39;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>

<h2 id="My-solution"><a href="#My-solution" class="headerlink" title="My solution"></a>My solution</h2><p> 可能是今天上了一天的课，弄的头晕。读题没读仔细，害的这道题解了半天，其实之前就已经做出来了！我想多测试几个testcase，结果发现已经做出来的方法没写对，然后又重新写，结果越写越复杂。所以这件事说明了<strong><em>仔细的重要性</em></strong> 。 我遇到的坑就是——–&gt; 题目中说的 a <strong><em>sorted</em></strong> array nums. 意思就是这个数组里面的元素是已经排好顺序的。 我测试完这两个example以后发现没问题。又测试[0,1,2,2,4,3,4] 等等testcase，结果发现我的方法得不到正解。 其实是我的testcase写错了。 </p>
<p> 首先根据维基百科的解答<a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> ，我的理解就是<strong><em>原地算法就是只在现有的数组里面操作，不额外的引入新的数组或者开辟新的空间。 仅仅是依靠输出来覆盖输入的一种算法</em></strong>。</p>
<p>  理解了in-place algorithm以后， 我就谈谈我的思路。</p>
<p>   按照顺序把数组里面的两个最近数字两两比较，如果前后不一样就用后面的数字替换前面的数字。因此这里就是for循环然后if条件判断。  但是又是一个问题，有可能有连续2个以上的数字都是一样的。比如example 2 里面 有三个1连续。 那么答案显然第一个2要替换第二个1。 由于第一个1替换了第二个0，则第一个1的index是1。 所以第一个2的index是2.    所以需要计算不同数字替换前面的连续相同数字以后的index。 我就想到了计算连续相同数字的判断次数 x. 然后用不同数字原本的index减去x得到不同数字替换连续相同数字以后的index。这样依靠后一个不同数字替换前连续相同数字，就可以得到新的nums数组。返回的integer是新的nums数组里面前面不同数字的个数。  </p>
<h2 id="具体的代码如下"><a href="#具体的代码如下" class="headerlink" title="具体的代码如下"></a>具体的代码如下</h2> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">         <span class="keyword">int</span> result = <span class="number">1</span>; </span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; nums.length; i++)&#123;   </span><br><span class="line">              <span class="keyword">if</span>(temp==nums[i])&#123;</span><br><span class="line">                  count+=<span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">             </span><br><span class="line">              <span class="keyword">if</span>(temp != nums[i])&#123;                  </span><br><span class="line">                    temp=nums[i];</span><br><span class="line">                    nums[i-count]=nums[i];</span><br><span class="line">                    result+=<span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><h4 id="Example1"><a href="#Example1" class="headerlink" title="Example1"></a>Example1</h4><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/04/tI1gXF4MlC8Ydjb.png" alt=""></p>
<h4 id="Example-2-1"><a href="#Example-2-1" class="headerlink" title="Example 2"></a>Example 2</h4><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/04/RCnszbgoL26VqZF.png" alt=""></p>
<h4 id="More-TestCase"><a href="#More-TestCase" class="headerlink" title="More TestCase"></a>More TestCase</h4><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/04/d5GK76Yv23DS4Hm.png" alt=""></p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/04/OP2posEgt3hCDfJ.png" alt=""></p>
<p>可见我的方法没有问题。 a <strong><em>sorted</em></strong> array nums 的testcase要注意啊！ </p>
<p>复习一下时间复杂度。 这个解法的时间复杂度是O(n).  </p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/04/miDky3obu5cHARE.png" alt=""></p>
<h2 id="Leetcode-Clarification"><a href="#Leetcode-Clarification" class="headerlink" title="Leetcode Clarification"></a>Leetcode Clarification</h2><p>在leetcode里面的clarification解释为什么返回值是integer但是答案是数组。</p>
<h4 id="Note-that-the-input-array-is-passed-in-by-reference-which-means-modification-to-the-input-array-will-be-known-to-the-caller-as-well"><a href="#Note-that-the-input-array-is-passed-in-by-reference-which-means-modification-to-the-input-array-will-be-known-to-the-caller-as-well" class="headerlink" title="Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well."></a>Note that the input array is passed in by <strong><em>reference</em></strong>, which means modification to the input array will be known to the caller as well.</h4><p>Internally you can think of this:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums is passed in by reference. (i.e., without making a copy)</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// any modification to nums in your function would be known by the caller.</span></span><br><span class="line"><span class="comment">// using the length returned by your function, it prints the first len elements.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Leetcode的Solution"><a href="#Leetcode的Solution" class="headerlink" title="Leetcode的Solution"></a>Leetcode的Solution</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Time complextiy : O(n). Assume that n is the length of array. Each of i and j traverses at most <em>n</em> steps.</li>
<li>Space complexity : O(1).</li>
</ul>
<p>这道题应该是没什么难度。就是自己读题不仔细在testcase那里犯了错。 </p>
]]></content>
      <categories>
        <category>Leetcode Algorithm</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Leetcode Algorithm</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>Restore IP Addresses</title>
    <url>/2021/07/16/Restore-IP-Addresses/</url>
    <content><![CDATA[<h2 id="Restore-IP-Addresses"><a href="#Restore-IP-Addresses" class="headerlink" title="Restore IP Addresses"></a>Restore IP Addresses</h2><p><a href="https://leetcode.com/problems/restore-ip-addresses/description/" target="_blank" rel="noopener">Leetcode  93.</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; addresses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    StringBuilder tempAddress = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    backtricking(s,addresses,tempAddress,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> addresses; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtricking</span><span class="params">(String input,List&lt;String&gt; address,StringBuilder tempAddress,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//recursion stop condition</span></span><br><span class="line">     <span class="keyword">if</span>(k == <span class="number">4</span> || input.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//collect result </span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">4</span> &amp;&amp; input.length() == <span class="number">0</span>)&#123;</span><br><span class="line">          address.add(tempAddress.toString());  </span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//for loop :  Set of elements in this layer</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span> &amp;&amp; i &lt; input.length();i++)&#123;</span><br><span class="line">         <span class="comment">//process nodes according to the requirements</span></span><br><span class="line">         <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; input.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)&#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         String part = input.substring(<span class="number">0</span>,i+<span class="number">1</span>);</span><br><span class="line">         <span class="keyword">if</span>(Integer.valueOf(part) &lt;= <span class="number">255</span>)&#123;</span><br><span class="line">             <span class="keyword">if</span>(tempAddress.length() != <span class="number">0</span>)&#123;</span><br><span class="line">                 part = <span class="string">"."</span> + part;</span><br><span class="line">             &#125;</span><br><span class="line">             tempAddress.append(part);</span><br><span class="line">             <span class="comment">//recursion</span></span><br><span class="line">             backtricking(input.substring(i+<span class="number">1</span>),address,tempAddress,k+<span class="number">1</span>);</span><br><span class="line">             <span class="comment">//backtricking and undo the previous processing node</span></span><br><span class="line">             tempAddress.delete(tempAddress.length() - part.length(),tempAddress.length());</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode Algorithm</category>
        <category>Backtricking</category>
      </categories>
      <tags>
        <tag>Leetcode Algorithm</tag>
        <tag>Backtricking</tag>
      </tags>
  </entry>
</search>
