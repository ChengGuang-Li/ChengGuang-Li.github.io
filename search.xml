<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetcodeTwoSum1</title>
      <link href="/2020/08/03/LeetcodeTwoSum1/"/>
      <url>/2020/08/03/LeetcodeTwoSum1/</url>
      
        <content type="html"><![CDATA[<h1 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h1><h2 id="Question-Easy"><a href="#Question-Easy" class="headerlink" title="Question     * Easy *"></a>Question     <strong>* Easy *</strong></h2><h3 id="Given-an-array-of-integers-return-indices-of-the-two-numbers-such-that-they-add-up-to-a-specific-target-You-may-assume-that-each-input-would-have-exactly-one-solution-and-you-may-not-use-the-same-element-twice"><a href="#Given-an-array-of-integers-return-indices-of-the-two-numbers-such-that-they-add-up-to-a-specific-target-You-may-assume-that-each-input-would-have-exactly-one-solution-and-you-may-not-use-the-same-element-twice" class="headerlink" title="Given an array of integers, return indices of the two numbers such that they add up to a specific target.  (You may assume that each input would have exactly one solution, and you may not use the same element twice.)"></a>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.  (You may assume that each input would have <strong><em>exactly</em></strong> one solution, and you may not use the <em>same</em> element twice.)</h3><h2 id="Hints："><a href="#Hints：" class="headerlink" title="Hints："></a>Hints：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] resultArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">                 result = nums[i] + nums[j]; </span><br><span class="line">                 <span class="keyword">if</span>(result == target)&#123;</span><br><span class="line">                      resultArray[<span class="number">0</span>] = i;</span><br><span class="line">                      resultArray[<span class="number">1</span>] = j;</span><br><span class="line">                      <span class="keyword">return</span> resultArray; </span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">     &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">         System.out.println(<span class="string">"There is no solution"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> resultArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的想法是 通过遍历所提供的数组，如果可以找到两数相加等于目标数。这样就可以返回这两个数字的Index。然后把这两个数的Index 形成一个新的数组作为return。  </p><p>  但是我在看solution的时候，发现我的解题思路被归类为 Brute Force.  solution里面还有其他方法 Two- pass Hash Table, One-Pass Hash Table.  我的解题方法被归类为Brute Force是因为 time complexity == O($n^2$) .  我的这种方法对于每一个元素，每一次loop数组剩下的元素查找它的补数需要花的时间是O(n)，所以两层for循环下来 time complexity == O($n^2$). 可见下图，我的方法不是优解，时间复杂度有点高。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/03/nvqw9jb2zcUtxXZ.png" alt=""></p><h2 id="TIME-COMPLEXITY"><a href="#TIME-COMPLEXITY" class="headerlink" title="TIME COMPLEXITY"></a>TIME COMPLEXITY</h2><p>​    语句执行次数称为语句频度或时间频度,记为T(n)。 有了基本操作执行次数的函数T(n)也无法准确比较代码的运行时间。 比如算法A T(n) = 100n, 算法B T(n) = 5$n^2$,算法A和算法B谁的运行时间长就和n的取值有关了。因此有了<strong><em>渐进时间复杂度</em></strong> (Asymptotic  Time Complexity)的概念.   </p><p>​    若有某个<strong>辅助函数f(n)</strong>,使得当n趋近于无穷大时，T(n) /  f(n)  的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作：T(n)  =  O(f(n))， 称 O(f(n)) 为算法的渐进时间复杂度，简称<strong><em>时间复杂度</em></strong>，也称大O表示法。   <strong><em>时间复杂度决定了程序的运行效率，因此特别重要</em></strong></p><p>   <strong>时间复杂度原则</strong>： </p><ol><li><strong><em>如果运行时间 T(n)是常数量级，则 O(1) 表示。</em></strong></li><li><strong><em>T(n) 只保留时间函数中的最高阶项。</em></strong></li><li><strong><em>T(n) 可以省去最够阶项前面的系数。</em></strong> </li></ol><p>这篇简书的文章写的很好：<a href="https://www.jianshu.com/p/f4cca5ce055a" target="_blank" rel="noopener">https://www.jianshu.com/p/f4cca5ce055a</a></p><p>这篇漫画解释时间复杂度及其重要性也写得很好：<a href="https://www.cxyxiaowu.com/5323.html" target="_blank" rel="noopener">https://www.cxyxiaowu.com/5323.html</a></p><h2 id="Two-pass-Hash-Table"><a href="#Two-pass-Hash-Table" class="headerlink" title="Two-pass Hash Table"></a>Two-pass Hash Table</h2><p>  利用hash table，将空间换为速度从而把查找时间降低。利用hash table几乎可以快速查找。“几乎”是因为冲突发生，查找时间还是会退化回去。  在Two-pass Hash Table里面会用到两次iterations.第一次是把每一个元素的value和index添加进table。第二次是查找元素的补数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, map.get(complement) &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，时间复杂度就是O(n)，显然没有嵌套的for循环。 每一次查询时间是O(1). </p><h2 id="One-pass-Hash-Table"><a href="#One-pass-Hash-Table" class="headerlink" title="One-pass Hash Table"></a>One-pass Hash Table</h2><p> 和 two-pass hash table 不同的就是， one-pass hash table可以 <strong><em>insert</em></strong> element into table 的时候 <strong><em>check</em></strong> 当前 元素的补数是否已经存在表格里了。如果存在 则返回solution。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; map.get(complement), i &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 时间复杂度也显然是O(n). 空间复杂度也是O(n)，额外的空间取决于有多少的items要存进hash table. </p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>   <strong>创建对象</strong>——&gt;  <code>HashMap&lt;String,Integer&gt; hashMap = new HashMap&lt;&gt;();</code></p><p>   <strong>存储数据</strong>   通过put （key,value)——&gt; <code>hashMap.put(&quot;aa&quot;,1);</code></p><p>   put方法会覆盖原有的value。另一种方法putIfAbsent(key,value) 不会覆盖。 </p><p>​    <code>hashMap.putIfAbsent(&quot;aa&quot;,4);</code></p><p>   <strong>删除元素</strong>  </p><p>   remove(key):删除成功(存在key)，返回被删除的key对应的value，否则返回null。</p><p>   remove(key,value):删除成功（存在entry），返回true，否则返回false。 </p><p>​    <code>hashMap.remove(&quot;aa&quot;,5);</code></p><p>   <strong>获取元素</strong></p><p>   <code>hashMap.get(&quot;aa&quot;);</code></p><p>   getOrDefault在key不存在时,返回一个defaultValue。</p><p>​    <code>getOrDefault(&quot;aa&quot;,-1);</code></p><p>  <strong>元素遍历</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator iterator &#x3D; hashMap.keySet().iterator();</span><br><span class="line">while (iterator.hasNext())&#123;</span><br><span class="line">    String key &#x3D; (String)iterator.next();</span><br><span class="line">    System.out.println(key+&quot;&#x3D;&quot;+hashMap.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断Key或者value是否存在</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hashMap.containsKey(&quot;aa&quot;);</span><br><span class="line">hashMap.containsValue(1);</span><br></pre></td></tr></table></figure><p><strong>替换元素</strong></p><p><code>hashMap.replace(&quot;ff&quot;,5);</code></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode Algorithm </category>
          
          <category> Two Sum </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode Algorithm </tag>
            
            <tag> Two Sum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8/03-8/09 schedule</title>
      <link href="/2020/08/02/8-03-8-09-schedual/"/>
      <url>/2020/08/02/8-03-8-09-schedual/</url>
      
        <content type="html"><![CDATA[<h1 id="8-03-8-09-schedule"><a href="#8-03-8-09-schedule" class="headerlink" title="8/03-8/09 schedule"></a>8/03-8/09 schedule</h1><table><thead><tr><th>Time</th><th>Mon</th><th>Tue</th><th>Wed</th><th>Thu</th><th>Fri</th><th>Sat</th><th>Sun</th></tr></thead><tbody><tr><td>8:00 am - 10:00 am</td><td>FIT5147 Lab</td><td>FIT5140 Lecture</td><td>练习听力 + Leetcode  Java</td><td>练习 听力 + SWIFT</td><td>练习听力 + Leetcode  Java</td><td>记单词+ Leetcode  Java</td><td>记单词+ Leetcode  Java</td></tr><tr><td>10:00 am - 12: 00 am</td><td>Leetcode   Java</td><td>练习 SWIFT</td><td>预习FIT5042</td><td>Leetcode Java</td><td>FIT5147 Lec</td><td>休息</td><td>Leetcode  Java</td></tr><tr><td>12:00pm - 1:50pm</td><td>吃饭 &amp;&amp; 午睡</td><td>吃饭 &amp;&amp; 午睡</td><td>FIT5042 Lab</td><td>吃饭 &amp;&amp; 午睡</td><td>吃饭 &amp;&amp; 午睡</td><td>休息</td><td>吃饭 &amp;&amp; 午睡</td></tr><tr><td>2:00 pm - 4: 00 pm</td><td>FIT5137 Lab</td><td>预习FIT5042(Spring MVC)</td><td>FIT5042 Lab + 锻炼</td><td>预习FIT5042(Spring MVC)</td><td>预习FIT5140</td><td>Leetcode  Java</td><td>练习 d3</td></tr><tr><td>4:00 pm - 6: 00 pm</td><td>学习 Java EE</td><td>Leetcode Java +  FIT5202 Lab</td><td>休息+ 练习 R</td><td>Leetcode Java + 吃饭</td><td>Leetcode  Java + 吃饭</td><td>练习 Swift</td><td>送 Min</td></tr><tr><td>6: 00 pm - 7: 00pm</td><td>吃饭 &amp;&amp; 休息</td><td>FIT5202 Lab</td><td>吃饭 &amp;&amp; 休息</td><td>FIT5137  Lecture</td><td>FIT5140 Lab</td><td>吃饭 &amp;&amp; 休息</td><td>吃饭 &amp;&amp; 休息</td></tr><tr><td>7: 00 pm - 8: 00 pm</td><td>锻炼</td><td>FIT5042 Lecture</td><td>FIT5202 Lec</td><td>FIT5137  Lecture</td><td>FIT5140 Lab</td><td>休息</td><td>锻炼</td></tr><tr><td>8: 00 pm - 10: 00 pm</td><td>Leetcode  Java</td><td>FIT5042 Lecture+ 吃饭</td><td>Leetcode Java + 锻炼</td><td>Leetcode Java + 锻炼</td><td>刷 面试题</td><td>练习 R</td><td>刷面试题 + 定 下周计划</td></tr><tr><td>10:00 pm - 11: 30 pm</td><td>博客总结  + 洗漱   然后睡觉</td><td>博客总结  + 洗漱   然后睡觉</td><td>博客总结  + 洗漱   然后睡觉</td><td>博客总结  + 洗漱   然后睡觉</td><td>博客总结  + 洗漱   然后睡觉</td><td>博客总结  + 洗漱   然后睡觉</td><td>博客总结  + 洗漱   然后睡觉</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> schedule </category>
          
      </categories>
      
      
        <tags>
            
            <tag> schedule </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
