[{"title":"8/03-8/09 schedule","url":"/2020/08/02/8-03-8-09-schedual/","content":"<h1 id=\"8-03-8-09-schedule\"><a href=\"#8-03-8-09-schedule\" class=\"headerlink\" title=\"8/03-8/09 schedule\"></a>8/03-8/09 schedule</h1><table>\n<thead>\n<tr>\n<th>Time</th>\n<th>Mon</th>\n<th>Tue</th>\n<th>Wed</th>\n<th>Thu</th>\n<th>Fri</th>\n<th>Sat</th>\n<th>Sun</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>8:00 am - 10:00 am</td>\n<td>FIT5147 Lab</td>\n<td>FIT5140 Lecture</td>\n<td>练习听力 + Leetcode  Java</td>\n<td>练习 听力 + SWIFT</td>\n<td>练习听力 + Leetcode  Java</td>\n<td>记单词+ Leetcode  Java</td>\n<td>记单词+ Leetcode  Java</td>\n</tr>\n<tr>\n<td>10:00 am - 12: 00 am</td>\n<td>Leetcode   Java</td>\n<td>练习 SWIFT</td>\n<td>预习FIT5042</td>\n<td>Leetcode Java</td>\n<td>FIT5147 Lec</td>\n<td>休息</td>\n<td>Leetcode  Java</td>\n</tr>\n<tr>\n<td>12:00pm - 1:50pm</td>\n<td>吃饭 &amp;&amp; 午睡</td>\n<td>吃饭 &amp;&amp; 午睡</td>\n<td>FIT5042 Lab</td>\n<td>吃饭 &amp;&amp; 午睡</td>\n<td>吃饭 &amp;&amp; 午睡</td>\n<td>休息</td>\n<td>吃饭 &amp;&amp; 午睡</td>\n</tr>\n<tr>\n<td>2:00 pm - 4: 00 pm</td>\n<td>FIT5137 Lab</td>\n<td>预习FIT5042(Spring MVC)</td>\n<td>FIT5042 Lab + 锻炼</td>\n<td>预习FIT5042(Spring MVC)</td>\n<td>预习FIT5140</td>\n<td>Leetcode  Java</td>\n<td>练习 d3</td>\n</tr>\n<tr>\n<td>4:00 pm - 6: 00 pm</td>\n<td>学习 Java EE</td>\n<td>Leetcode Java +  FIT5202 Lab</td>\n<td>休息+ 练习 R</td>\n<td>Leetcode Java + 吃饭</td>\n<td>Leetcode  Java + 吃饭</td>\n<td>练习 Swift</td>\n<td>送 Min</td>\n</tr>\n<tr>\n<td>6: 00 pm - 7: 00pm</td>\n<td>吃饭 &amp;&amp; 休息</td>\n<td>FIT5202 Lab</td>\n<td>吃饭 &amp;&amp; 休息</td>\n<td>FIT5137  Lecture</td>\n<td>FIT5140 Lab</td>\n<td>吃饭 &amp;&amp; 休息</td>\n<td>吃饭 &amp;&amp; 休息</td>\n</tr>\n<tr>\n<td>7: 00 pm - 8: 00 pm</td>\n<td>锻炼</td>\n<td>FIT5042 Lecture</td>\n<td>FIT5202 Lec</td>\n<td>FIT5137  Lecture</td>\n<td>FIT5140 Lab</td>\n<td>休息</td>\n<td>锻炼</td>\n</tr>\n<tr>\n<td>8: 00 pm - 10: 00 pm</td>\n<td>Leetcode  Java</td>\n<td>FIT5042 Lecture+ 吃饭</td>\n<td>Leetcode Java + 锻炼</td>\n<td>Leetcode Java + 锻炼</td>\n<td>刷 面试题</td>\n<td>练习 R</td>\n<td>刷面试题 + 定 下周计划</td>\n</tr>\n<tr>\n<td>10:00 pm - 11: 30 pm</td>\n<td>博客总结  + 洗漱   然后睡觉</td>\n<td>博客总结  + 洗漱   然后睡觉</td>\n<td>博客总结  + 洗漱   然后睡觉</td>\n<td>博客总结  + 洗漱   然后睡觉</td>\n<td>博客总结  + 洗漱   然后睡觉</td>\n<td>博客总结  + 洗漱   然后睡觉</td>\n<td>博客总结  + 洗漱   然后睡觉</td>\n</tr>\n</tbody></table>\n","categories":["schedule"],"tags":["schedule"]},{"title":"LeetcodeTwoSum1","url":"/2020/08/03/LeetcodeTwoSum1/","content":"<h1 id=\"Two-Sum\"><a href=\"#Two-Sum\" class=\"headerlink\" title=\"Two Sum\"></a>Two Sum</h1><h2 id=\"Question-Easy\"><a href=\"#Question-Easy\" class=\"headerlink\" title=\"Question     * Easy *\"></a>Question     <strong>* Easy *</strong></h2><h3 id=\"Given-an-array-of-integers-return-indices-of-the-two-numbers-such-that-they-add-up-to-a-specific-target-You-may-assume-that-each-input-would-have-exactly-one-solution-and-you-may-not-use-the-same-element-twice\"><a href=\"#Given-an-array-of-integers-return-indices-of-the-two-numbers-such-that-they-add-up-to-a-specific-target-You-may-assume-that-each-input-would-have-exactly-one-solution-and-you-may-not-use-the-same-element-twice\" class=\"headerlink\" title=\"Given an array of integers, return indices of the two numbers such that they add up to a specific target.  (You may assume that each input would have exactly one solution, and you may not use the same element twice.)\"></a>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.  (You may assume that each input would have <strong><em>exactly</em></strong> one solution, and you may not use the <em>same</em> element twice.)</h3><h2 id=\"Hints：\"><a href=\"#Hints：\" class=\"headerlink\" title=\"Hints：\"></a>Hints：</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class=\"line\"></span><br><span class=\"line\">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class=\"line\">return [0, 1].</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"My-Solution\"><a href=\"#My-Solution\" class=\"headerlink\" title=\"My Solution\"></a>My Solution</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] resultArray = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">     <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class=\"line\">                 result = nums[i] + nums[j]; </span><br><span class=\"line\">                 <span class=\"keyword\">if</span>(result == target)&#123;</span><br><span class=\"line\">                      resultArray[<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">                      resultArray[<span class=\"number\">1</span>] = j;</span><br><span class=\"line\">                      <span class=\"keyword\">return</span> resultArray; </span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">     &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">         System.out.println(<span class=\"string\">\"There is no sun solution\"</span>);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resultArray;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我的想法是 通过遍历所提供的数组，如果可以找到两数相加等于目标数。这样就可以返回这两个数字的Index。然后把这两个数的Index 形成一个新的数组作为return。  </p>\n<p>  但是我在看solution的时候，发现我的解题思路被归类为 Brute Force.  solution里面还有其他方法 Two- pass Hash Table, One-Pass Hash Table.  我的解题方法被归类为Brute Force是因为 time complexity == O($n^2$) .  我的这种方法必须loop 这个数组来找到解答。 对于每一个元素，每一次loop数组剩下的元素查找它的补数需要花的时间是O(n)，所以两层for循环下来 time complexity == O($n^2$). 可见下图，我的方法不算优解，时间复杂度有点高。</p>\n<p><img src= \"/img/loading.gif\" data-src=\"https://i.loli.net/2020/08/03/nvqw9jb2zcUtxXZ.png\" alt=\"\"></p>\n<h2 id=\"TIME-COMPLEXITY\"><a href=\"#TIME-COMPLEXITY\" class=\"headerlink\" title=\"TIME COMPLEXITY\"></a>TIME COMPLEXITY</h2><p>​    语句执行次数称为语句频度或时间频度,记为T(n)。 有了基本操作执行次数的函数T(n)也无法准确比较代码的运行时间。 比如算法A T(n) = 100n, 算法B T(n) = 5$n^2$,算法A和算法B谁的运行时间长就和n的取值有关了。因此有了<strong><em>渐进时间复杂度</em></strong> (Asymptotic  Time Complexity)的概念.   </p>\n<p>​    若有某个<strong>辅助函数f(n)</strong>,使得当n趋近于无穷大时，T(n) /  f(n)  的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作：T(n)  =  O(f(n))， 称 O(f(n)) 为算法的渐进时间复杂度，简称<strong><em>时间复杂度</em></strong>，也称大O表示法。   <strong><em>时间复杂度决定了程序的运行效率，因此特别重要</em></strong></p>\n<p>   <strong>时间复杂度原则</strong>： </p>\n<ol>\n<li><strong><em>如果运行时间 T(n)是常数量级，则 O(1) 表示。</em></strong></li>\n<li><strong><em>T(n) 只保留时间函数中的最高阶项。</em></strong></li>\n<li><strong><em>T(n) 可以省去最够阶项前面的系数。</em></strong> </li>\n</ol>\n<p>这篇简书的文章写的很好：<a href=\"https://www.jianshu.com/p/f4cca5ce055a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/f4cca5ce055a</a></p>\n<p>这篇漫画解释时间复杂度及其重要性也写得很好：<a href=\"https://www.cxyxiaowu.com/5323.html\" target=\"_blank\" rel=\"noopener\">https://www.cxyxiaowu.com/5323.html</a></p>\n<p>我的解法是for循环嵌套，明显时间复杂度度是O($n^2$).  这样其实不是最优解！ </p>\n<h2 id=\"Two-pass-Hash-Table\"><a href=\"#Two-pass-Hash-Table\" class=\"headerlink\" title=\"Two-pass Hash Table\"></a>Two-pass Hash Table</h2><p>  利用hash table，将空间换为速度从而把查找时间降低。利用hash table几乎可以快速查找。“几乎”是因为冲突发生，查找时间还是会退化回去。  在Two-pass Hash Table里面会用到两次iterations.第一次是把每一个元素的value和index添加进table。第二次是查找元素的补数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">    Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        map.put(nums[i], i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> complement = target - nums[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123; i, map.get(complement) &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"No two sum solution\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样的话，时间复杂度就是O(n)，显然没有嵌套的for循环。 每一次查询时间是O(1). </p>\n<h2 id=\"One-pass-Hash-Table\"><a href=\"#One-pass-Hash-Table\" class=\"headerlink\" title=\"One-pass Hash Table\"></a>One-pass Hash Table</h2><p> 和 two-pass hash table 不同的就是， one-pass hash table可以 <strong><em>insert</em></strong> element into table 的时候 <strong><em>check</em></strong> 当前 元素的补数是否已经存在表格里了。如果存在 则返回solution。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">    Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> complement = target - nums[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map.containsKey(complement)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123; map.get(complement), i &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        map.put(nums[i], i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"No two sum solution\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 时间复杂度也显然是O(n). 空间复杂度也是O(n)，额外的空间取决于有多少的items要存进hash table. </p>\n<h2 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h2><p>   <strong>创建对象</strong>——&gt;  <code>HashMap&lt;String,Integer&gt; hashMap = new HashMap&lt;&gt;();</code></p>\n<p>   <strong>存储数据</strong>   通过put （key,value)——&gt; <code>hashMap.put(&quot;aa&quot;,1);</code></p>\n<p>   put方法会覆盖原有的value。另一种方法putIfAbsent(key,value) 不会覆盖。 </p>\n<p>​    <code>hashMap.putIfAbsent(&quot;aa&quot;,4);</code></p>\n<p>   <strong>删除元素</strong>  </p>\n<p>   remove(key):删除成功(存在key)，返回被删除的key对应的value，否则返回null。</p>\n<p>   remove(key,value):删除成功（存在entry），返回true，否则返回false。 </p>\n<p>​    <code>hashMap.remove(&quot;aa&quot;,5);</code></p>\n<p>   <strong>获取元素</strong></p>\n<p>   <code>hashMap.get(&quot;aa&quot;);</code></p>\n<p>   getOrDefault在key不存在时,返回一个defaultValue。</p>\n<p>​    <code>getOrDefault(&quot;aa&quot;,-1);</code></p>\n<p>  <strong>元素遍历</strong></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Iterator iterator &#x3D; hashMap.keySet().iterator();</span><br><span class=\"line\">while (iterator.hasNext())&#123;</span><br><span class=\"line\">    String key &#x3D; (String)iterator.next();</span><br><span class=\"line\">    System.out.println(key+&quot;&#x3D;&quot;+hashMap.get(key));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>判断Key或者value是否存在</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hashMap.containsKey(&quot;aa&quot;);</span><br><span class=\"line\">hashMap.containsValue(1);</span><br></pre></td></tr></table></figure>\n\n<p><strong>替换元素</strong></p>\n<p><code>hashMap.replace(&quot;ff&quot;,5);</code></p>\n","categories":["Leetcode Algorithm","Two Sum"],"tags":["Leetcode Algorithm","Two Sum"]}]